# 🔣 알고리즘 : BFS (Breadth First Search), ST(Spanning Tree)

DFS(Depth First Search)와 구분되는 탐색법 중 하나로, 선택한 노드의 인접한 노드를 먼저 탐색하는 전략이다.<br>
탐색법 중에서도 시간이 조금 걸리더라도 어쨌든 모든 경우를 탐색해봐야하는 경우에 자주 사용된다.<br>
최단 거리 찾기, 최단 시간(토마토 문제) 도출 등에 사용된다.<br><br>

반대로, DFS는 일단 빨리 길(목적노드)을 찾는게 우선인 경우에 사용<br><br>

ST(신장 트리) 는 트리 구조에서 최소한의 bridge(간선, N-1개) 를 이용해서 정점들을 모두 포함하는 트리 이다.<br>
즉 한 노드에서 다른 노드로 이동할 때 경로가 단 하나밖에 없는 구조를 나타낸다.<br>
현실에서 자원(케이블)이 한정되었을 때 가장 효율적인 연결 방법을 모색하고자 하는 경우에 채택될 수 있는 방식<br><br>

정점 : Node(트리 내에서 정점) 가 될 수 있는 후보 군<br>
트리 : 정점과 간선의 관계 집합

## ❗ 알고리즘

Node class 를 별도로 생성한 후 List<node>[] 를 만들어 해결할 수 있는 문제<br>
BFS 전개 방식은 Queue를 생성한 후 방문하지 않았고, 유사도가 k 보다 큰 경우에 추가적인 방문이 이루어지도록 구현<br>
위의 방식이 적용가능한 이유는 ST가 전제되었기 때문인데, 새로운 노드를 발견할 때 마다 그 노드를 만나는 경로가 "유일" 하다는 것을 의미해서<br>
그 때까지 유사도가 k 보다 크다면 추천 영상으로 추가하는 것이다.<br>
또한 방문경로가 유일하기 때문에 경로상에 유사도가 k보다 작은 것이 있다면 그 뒤로 만나는 노드들도 무조건 유사도가 낮은 동영상일 것이므로<br>
추가적인 탐색을 할 필요가 없다는 것을 의미한다.<br><br>


## ❗ 알고리즘 외

List<Object>[] = new ArrayList[size]<br> 
--> List<Object> 객체를 값으로 저장하는 배열 생성/ new ArrayList 이 부분에는 내부 값으로 들어갈 객체 지정<br>
결국 형태는 이차원 배열을 나타내므로 List<Object> 에 대한 초기화도 필요함<br>

처음 이차원 배열로 접근을 하였는데 ST 같은 경우에는 간선의 수가 너무 적어서<br>
모든 연관관계가 궁금한 이차원 배열과는 맞지 않는다고 한다. 전체 탐색이 필요할 때만 이차원 배열을 사용하자

## 🙂 정리

그래프 탐색 속도 올리기



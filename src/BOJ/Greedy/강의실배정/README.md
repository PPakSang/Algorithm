# 🔣 알고리즘 : Greedy

탐욕스럽고 욕심많은 전략을 택한다 해서 Greedy 하다고 불리는 이 알고리즘은<br>
나에게 당장 가장 많은 이득을 가져다 줄 것으로 예상되는 행동을 취하는 방식이다. ~~팃포텟?~~<br>
알고리즘을 학습하면서 느낀점은 수학적인 문항을 풀 때 자주나오고, 그렇기 때문에 조건식을 잘 만들어야한다.  
  
알고리즘에서 최적 하부 구조를 가지는 형태의 해를 찾는 것이 핵심  
사실 이 문장을 보고 한번에 와닿진 않았는데, 다음과 같은 의미를 가진다고 판단을 하였다.  
  
우선 최적 하부 구조를 가지는 해를 찾기 위해서는 매 문제 상황마다 이전의 해가 필요하지 않은 경우가 될 것이다.  
왜냐하면 이전의 해가 현재의 문제상황에 영향을 준다면 그리디의 본질인 "현재 선택할 수 있는 가장 최적의 해" 를 실천할 수 없을 것이다.  
오히려 DP 가 최적 하부 구조 및 이전의 해를 이용한 문제풀이에는 더 제격일 것이다.  
  
다시 돌아와서 현재 문제 상황에서 다음 문제상황으로 넘어갈 수 있는 선택지 중 현재 문제상황을 가장 크게(?) 해결할 수 있는 해를 찾는다.<br>  

간단한 증명(?) 이라고 하면, 다음 문제 상황이 이전 해와 아무런 연관이 없다는 전제가 있기 때문에   
당연히 현재 가장 이득을 취할 수 있는 해를 찾는 것이 그 이유이다.

## ❗ 알고리즘

강의실을 최대한 꼼곰하게 채워넣어야한다.  
꼼꼼하게 채워넣는다는 것은 다음 회차에 가장 빨리 시작하는 강의를 선택하는 것으로부터 시작할 수 있는데  
어차피 모든 강의를 선택해야하기 때문에 최적의 선택은 지금 당장 시작할 수 있는 강의를 빠르게 시작하는 것이다.  
다만 가장 빠른 강의를 잡았는데 넣을 시간표가 없다면 새로운 강의실을 생성해서 넣어야하는 것을 의미한다.  
  
가장 빠른 강의를 찾기 위해 모든 강의를 시작시간 기준으로 정렬을 해주고  
각 강의 별 끝나는 시간을 저장할 배열을 만들어 주는데, 강의실 별 가장 좋은 강의실은 빨리 수업이 마친 강의실이므로  
시간을 저장할 때는 최소값이 가장 첫 인덱스로 오도록 Priority Queue 를 구현해준다.
  
## ❗ 알고리즘 외

TreeSet 은 Comparator 가 뱉는 값에 따라서 중복을 체크한다

## 🙂 정리

없음 



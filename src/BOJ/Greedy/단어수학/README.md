# 🔣 알고리즘 : Greedy

탐욕스럽고 욕심많은 전략을 택한다 해서 Greedy 하다고 불리는 이 알고리즘은<br>
나에게 당장 가장 많은 이득을 가져다 줄 것으로 예상되는 행동을 취하는 방식이다. ~~팃포텟?~~<br>
알고리즘을 학습하면서 느낀점은 수학적인 문항을 풀 때 자주나오고, 그렇기 때문에 조건식을 잘 만들어야한다.  
  
알고리즘에서 최적 하부 구조를 가지는 형태의 해를 찾는 것이 핵심  
사실 이 문장을 보고 한번에 와닿진 않았는데, 다음과 같은 의미를 가진다고 판단을 하였다.  
  
우선 최적 하부 구조를 가지는 해를 찾기 위해서는 매 문제 상황마다 이전의 해가 필요하지 않은 경우가 될 것이다.  
왜냐하면 이전의 해가 현재의 문제상황에 영향을 준다면 그리디의 본질인 "현재 선택할 수 있는 가장 최적의 해" 를 실천할 수 없을 것이다.  
오히려 DP 가 최적 하부 구조 및 이전의 해를 이용한 문제풀이에는 더 제격일 것이다.  
  
다시 돌아와서 현재 문제 상황에서 다음 문제상황으로 넘어갈 수 있는 선택지 중 현재 문제상황을 가장 크게(?) 해결할 수 있는 해를 찾는다.<br>  

간단한 증명(?) 이라고 하면, 다음 문제 상황이 이전 해와 아무런 연관이 없다는 전제가 있기 때문에   
당연히 현재 가장 이득을 취할 수 있는 해를 찾는 것이 그 이유이다.

## ❗ 알고리즘

문제의 조건을 보고 풀이법을 파악해야 했던 문제.  
  
어떤 숫자인지 모르게 알파벳으로 가려진 숫자가 10개 나오는데, 합이 최대가 되도록 하는 알파벳 별 숫자를 찾아야한다  

숫자를 10개 더한다는 것은 아무리 큰 숫자가 오더라도 앞의 자릿수가 더 크다면 대소 관계가 역전이 되지 않는다는 것을 의미한다  
  
가령 888이 10개 와봤자 9000 1개 오는게 더 크다  
  
그래서 각 자리별로 숫자가 올 때 마다 10^(자릿수-1) 로 합한다.  
  
총 합해진 숫자를 정렬해서 큰 알파벳 별로 9 부터 0 까지 순서로 숫자를 배정한다

  
## ❗ 알고리즘 외

10진수의 체계에서 빈도를 체크할 때 10^(자릿수-1) 로 해보자

## 🙂 정리

처음에 무조건 자리 별 알파벳 빈도를 체크하는 문제라고 생각을 했다. 하지만 같은 자리에 두 알파벳의 빈도가 같다면  
  
어떻게 처리를 해줘야할지 고민이 됐다. 같은 알파벳에 대해서는 다음 자리 빈도를 또 체크하면 되긴하는데 만약 또 같다면 ?  
  
이 부분에서 재귀로 해야하나? 앞의 방법에서 배정된 숫자를 visited 를 써서 배정된 숫자를 제외하고 각 자리별로 수를 배정해야하나? 생각이 많았는데    
  
결국에는 깔끔한 방법이 생각이 나질 않아서  솔루션을 참고했다.  
  



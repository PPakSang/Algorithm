# 🔣 알고리즘 : Greedy

탐욕스럽고 욕심많은 전략을 택한다 해서 Greedy 하다고 불리는 이 알고리즘은<br>
나에게 당장 가장 많은 이득을 가져다 줄 것으로 예상되는 행동을 취하는 방식이다. ~~팃포텟?~~<br>
알고리즘을 학습하면서 느낀점은 수학적인 문항을 풀 때 자주나오고, 그렇기 때문에 조건식을 잘 만들어야한다.  
  
알고리즘에서 최적 하부 구조를 가지는 형태의 해를 찾는 것이 핵심  
사실 이 문장을 보고 한번에 와닿진 않았는데, 다음과 같은 의미를 가진다고 판단을 하였다.  
  
우선 최적 하부 구조를 가지는 해를 찾기 위해서는 매 문제 상황마다 이전의 해가 필요하지 않은 경우가 될 것이다.  
왜냐하면 이전의 해가 현재의 문제상황에 영향을 준다면 그리디의 본질인 "현재 선택할 수 있는 가장 최적의 해" 를 실천할 수 없을 것이다.  
오히려 DP 가 최적 하부 구조 및 이전의 해를 이용한 문제풀이에는 더 제격일 것이다.  
  
다시 돌아와서 현재 문제 상황에서 다음 문제상황으로 넘어갈 수 있는 선택지 중 현재 문제상황을 가장 크게(?) 해결할 수 있는 해를 찾는다.<br>  

간단한 증명(?) 이라고 하면, 다음 문제 상황이 이전 해와 아무런 연관이 없다는 전제가 있기 때문에   
당연히 현재 가장 이득을 취할 수 있는 해를 찾는 것이 그 이유이다.

## ❗ 알고리즘

스텝을 최소화 해야한다. 부가적으로 붙은 이득을 꾀할 수 있는 조건은 아래와 같다.  
1. 책을 여러권 들 수 있다.  
2. 마지막에는 돌아올 필요가 없다.

이를 바탕으로 그리디의 관점으로는 한번에 멀리있는 책을 여러권 챙겨들고 배달하고 와야 멀리 두 번 갈 일이 줄어들 수 있다는 것이다.  
또한 마지막에는 돌아올 필요가 없다는 말이 가장 멀리 있는 곳은 왔다 갔다 할 필요가 없다는 의미가 될 것이다.  
  
위 근거를 토대로 우선 좌, 우로 놓인 책 거리를 따로 정렬한다 (0 지점에서 책을 어차피 다시 가져갈 수 있기 때문에)  
좌 우 합쳐서 가장 멀리있는 위치부터 m개의 책 까지는 한 번만 방문하는 것이 이득이고, 나머지는 왔다 갔다 해야한다.  
왔다 갔다 할 때는 m 개씩 묶어서 가장 먼 곳만 두 번 왔다 갔다 하면된다.  
  
이 때 최적 하부 구조를 구하는 핵심은 가장 먼 곳 부터 갔다 와야하는 것인데, 그 이유가 가까운 곳 부터 m 개씩 묶으면  
책이 딱 m 개로 나눠 떨어지면 상관 없지만 m - k 개의 책이 최종적으로 남았다면 조금 아쉬운 보폭(?) 인데  
아쉬운 보폭은 짧을 거리를 가는 것에 쓰는 것이 최적의 해를 찾는 방법이다.
  
## ❗ 알고리즘 외

정렬이 필요한 케이스여서 삽입 삭제 탐색(subSet 생성) 모두 logN 이 소요되는 TreeSet 을 선택했다  
최적의 시간을 낼 것이라 기대했지만 다른 사람들의 풀이를 보니 Priority Queue 를 사용하는 것도 나쁘지 않아 보인다.  
  
TreeSet 의 subTree 는 List 자료형을 사용하기 때문에 toArray 호출이 가능하다.    
여기서 새로 안 부분인데 toArray 가 reference 타입의 경우에는 Object[] 로 변환한다.  
우리가 의도하는건 해당 List type Array 변환인데 이는 toArray 에 인자로 size -> Array 생성자 함수를 넘겨주면 된다.

## 🙂 정리

없음 



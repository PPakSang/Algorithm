# 🔣 알고리즘 : Dynamic Programming

동적계획법(Dynamic Programming)의 구현 방식에는 두가지가 있다.
1. Top-Down 방식의 **재귀(recursion)** 마지막에서 처음으로
2. Bottom-Up 방식의 **반복(iteration)** 처음에서 마지막으로

두 가지 방식에서 **반복되는 문제는 한 번만 푼다** 를 추가하면 Dynamic Programming 의 요구 조건을 만족시킨다.<br>
반복되는 문제를 한 번만 풀기 위해서는 Memoization(배열, 리스트, 집합 등을 사용하여)을 구현 하여야 한다.


## ❗ 알고리즘

dp[n] = dp[n-1].. 의 과정을 for(i=0 -> i=n) getDp(i) 의 방식으로 표현<br>
함수 내부에서는 dp[i] 를 찾는 과정이 나와있는데, 함수(i) 를 dp[i] 로 볼 수 있다.<br>
dp[i] 를 찾는 점화식은 i-1 부터 0까지 내려가면서...k dp[k] + 1 이 최대인 것을 구하면 된다<br>
이 풀이가 가능한 것이 조건 분기 기준이 현재 수보다 작은 수를 발견하면, 즉 작은 수를 마지막 수로 하는 부분수열에서 현재 수를 추가하는 개념<br>

## ❗ 알고리즘 외

for() {재귀 return} => n^2<br>
for() {재귀} => n^3

## 🙂 정리

dp[i] 의 기준을 잘 세울 필요가 있다. i를 기준으로 현재 과정을 표현할 방법을 찾자<br>
전체 문제 상황을 전부 활용할 수 있다. 이 문제를 풀면서도 완전 탐색을 해야하나? 싶었는데<br>  
시간제한 + 완전탐색 의심이 들면 dp 전체 탐색을 한번 고려해보도록 하자
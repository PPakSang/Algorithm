# 🔣 알고리즘 : BackTracking

DFS와 매우 유사한 BackTracking 은 Graph/Tree 공간에서 탐색하는 DFS 와 Problem Space 에서 탐색을 해나간다는 점에서
구분이 된다.<br>
상태를 저장하고 목적함수와 부합하는 해를 찾아나가는 방식

## ❗ 알고리즘

처음(Main2)에는 2차원 배열을 만들어 퀸을 하나 놓고 영향을 미치는 공간을 다 지우고 > 그 다음칸에 놓고의 방식으로 구현했다.<br>
결과는 **메모리초과**, 아무래도 2차원 배열+재귀는 메모리를 많이 사용하는 것 같아 방식을 바꾸었다.<br><br>

임의의 칸에 퀸을 놓았을 때 다음 열에서 퀸을 놓지 못할 조건은 일차원 배열로도 충분히 커버가 가능했고 코드를 참조하면 된다.<br>
순서는 퀸을 하나씩 놓아보고, 조건을 검사하여 놓을 수 있으면 다음 열을 놓으러 간다.<br>
backtracking 핵심은 for문 안에서 재귀를 수행하고, 재귀를 수행하고 돌아와서는 같은 계층의 다음 순번이 실행되는 느낌으로 문제를 풀어나간다. 

## ❗ 알고리즘 외

Array.clone() 은 깊은복사가 맞지만 2차원 배열의 경우에는<br>
<ul>
<li>int[][]의 주소 : x066</li>
<ul>
<li>int[]의 주소 : x053</li>
<li>int[]의 주소 : x054</li>
</ul>
</ul>

에서 저 x066만 깊은복사 효과를 내고 x053, x054 의 주소는 그대로 들고간다.<br>


## 🙂 정리

2차원 배열을 사용할 때는 신중하게 생각하고 사용하자<br>
2차원 배열을 1차원배열로 커버할 수 있는 경우를 생각하자.


 

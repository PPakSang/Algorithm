# 🔣 알고리즘 : Divide and Conquer

큰 문제를 풀 수 있는 작은 문제들의 합으로 해결하는 알고리즘<br>
Dynamic Programming 과 간혹 헷갈릴 수 있다.<br>
부분해를 다음 단계에 이용하는(Memoization) DP 와 달리 DC는 각각의 부분해가 다음 단계에 영향을 미치지 않는다.

## ❗ 알고리즘

좌표평면 공간에 뿌려진 점들 중 가장 최단거리에 있는 한 쌍의 점을 구하는 문제<br>
각 좌표 쌍을 모두 확인하는 nC2 를 사용하면 O(n^2) 로 탐색이 가능하다<br>
단 탐색을 하려고 생각을 해보면 너무 터무니 없는 점들 까지도(가령 두 점의 길이가 5인데, 다른 점을 살피려고 보니 이미 x 좌표 차이가<br>
1000 정도 난다던가 하는 케이스) 탐색을 하는 상황이 온다.<br><br>

이런 문제는 동일한 작은 문제로 쪼개서 생각해볼 필요가 있는 문제<br>
가장 쉽게 문제를 쪼개는 방법은 전체 점을 절반으로 나눠서 생각해보는건데, 어떻게 절반 위치에 있는 점을 알지? 라고 한다면 x 축 혹은 y 축<br>
을 통해 알 수 있다. 전체 점을 한 축에 대하여 정렬한다면 중앙에 있는 점은 분명 x 축에 수직한 선을 그었을 때 절반을 나누는 선이 될 것이다.<br>
<br>
반반 씩 계속 나누다가 3개의 점이 남았을 때 각 점들간의 거리 중 최소가 되는 거리를 구한다.<br>
다만 해당 작업만 한다면 좌 우에 있는 점이 이어졌을 때 최소가 되는 거리를 고려하지 못한다.<br>
따라서 좌 우 두 최소값 중 더 작은 값 m 을 구하면 그 값을 가지고 중앙에 있는 점에서부터 좌 우로 m 만큼 떨어져 있는 점을 선별한다.<br>
해당 점들 중 다시 점과 점사이의 거리가 m 이하인 점을 찾고 해당 점들의 거리를 구하여 m 값과 비교한다<br><br>

위 작업을 생각하면서 이것도 나름 오래 걸리겠는데? 싶어서 시간복잡도를 한번 구해보았는데(정확하지 않을 수 있음)<br>
마스터 정리에 의해 2T(n/2) + O(n) 까지 하면 (분할 logN, subproblem 중 x 값 차이가 m 보다 작은 것 탐색 n) nlogn 이 나오고<br>
각 과정마다 y 축에 관해 소팅을 해줘야하므로 nlog^2n 이 나온다.

## ❗ 알고리즘 외

parse, of 류 메소드의 기본 차이점은 String+primitive Vs 객체 인스턴스 생성 이다.

## 🙂 정리

실수를 줄이자
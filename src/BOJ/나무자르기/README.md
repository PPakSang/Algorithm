# 🔣 알고리즘 : Binary Search

시간복잡도 O(logN) 인 알고리즘 <br>
Search 를 구현하기 위해서는 정렬된 배열이 필요<br><br>

탐색군이 존재할 때 내가 구하려는 값이 외부요인은 상관없고 탐색군에 의해서 결정될 때 사용
1. 탐색군에서 10과 가장 가까운 수 구하기
2. 오차함수의 값이 가장 작을 때의 기준값(이번 문제)


와 같이 답 자체가 탐색군의 값만을 사용해서 도출해낼 수 있고<br>
특정 기준을 통해 값의 범위를 절반씩 줄여나갈 수 있으면 Binary Search 를 사용해 보자

## ❗ 알고리즘

이번 문제에서 Binary Search 가 사용될 수 있었던 이유는 다음과 같다.
1. 나무를 자르는 높이(답)의 범위가 (0 ~ 최대 나무의 높이) 이다.
2. 오차함수(각 나무 - 높이의 합)의 값이 목표(M)와 일치한가를 탐색한다. 즉 탐색군에 의해서 답이 결정된다.

<br>
0과 나무 최대값의 중간값으로 오차함수를 비교해본다.<br>

1. 오차함수 >= 목표치 ... 높이 최소값을 중간값+1으로 올린다<br>
2. 오차함수 <  목표치 ... 높이 최대값을 중간값-1으로 내린다<br>

종료조건 : min > max 이 참일 때 ... while(max >= min) 로 확인<br>
타겟일 때 최소값을 옮겼으므로, min max 동일 할 때는 최대값을 내린다.<br>

## ❗ 알고리즘 외

수평 좌표계에서 몫 연산은 왼쪽으로 붙는다는거 항상 생각하기<br>
타겟일 때, 종료조건일 때 상황을 꼼꼼하게 생각해보자

## 🙂 정리

타겟일 때 어떤 방식으로 탐색 범위를 축소할 지만 결정하고, mid + 1, mid - 1 로 줄여나가는 것 잘 생각하자 
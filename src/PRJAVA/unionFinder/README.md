# ☑️ Union Finder

조사할 데이터들의 **인덱스** 가 배열의 형태로 저장이 돼 있을 때  
임의의 index1 과 index2 를 같은 그룹으로 묶을 수 있는 방법이다.  
  
크게 union (그룹화 하는 메소드) 와 find (특정 index 의 그룹번호를 찾는 메소드) 로 나뉘고  
index1 의 그룹과 index2 의 그룹 중 그룹의 번호가 작은 것이 부모 그룹이 되는 방식으로 구현 가능하다.  
  
우선 모든 인덱스 별 각자의 그룹을 가지는 배열 arr[0:] = {0, 1, 2 ...} 을 생성하고  
union(1, 2) 를 수행한다면 1의 그룹과 2의 그룹 중 그룹 번호가 큰 것을 작은 그룹에 넣는다.  
가령 find(1) 이 10 이고 find(2) 가 0 이라면  
union(1, 2) 의 결과는 arr[1] 이 0이 되어야하고, arr[2] 는 그대로 0이 된다.  
  
구현 방식은 아래와 같다  

## ❗ find(int index)
해당 인덱스의 그룹 넘버가 인덱스와 동일하다면 (루트 그룹) 그대로 그룹 넘버를 반환한다  
그렇지 않다면 나의 부모 그룹 넘버의 그룹 넘버를 구해야한다.  
왜 부모 그룹 넘버의 **그룹 넘버** 를 또 구해야하냐면, 내가 부모 그룹이라고 저장했던 인덱스가  
다시 다른 부모 그룹에 편입되는 경우가 있기 때문이다.  
코드로 표현하면 arr[findIndex] = find(arr[findIndex]); 가 되겠다.  

## ❗ union(int x, int y)
두 개의 인덱스 그룹을 하나의 그룹으로 합치는 메소드이다.  
특별할 것은 없고 그룹 넘버가 더 큰 인덱스를 더 작은 인덱스와 동일한 그룹으로 변경하는 것이다.  
find(x), find(y) 를 통해 각각의 그룹 넘버를 구한 뒤 진행한다.